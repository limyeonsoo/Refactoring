# 3. smell of the code

# [언제] / [어디까지] 리팩터링을 진행해야 할까?

> "코드에서 냄새가 날 때" (when)

> "각자 경험에서 감을 찾자" (How Far)

## 1. Mysterious Name (기이한 이름)

누가봐도 명백한 의도를 알 수 있는 '변수명', '함수명', '필드명' 등은 최고다.

- 문맥 파악이 쉽다.
- 직관적으로 찾아보지 않아도 의도가 떠오를 수 있다.

## 2. Duplicated Code (중복 코드)

똑같은 코드 구조가 반복된다면 하나로 통합하자.

**⭐ 코드가 중복되면 각 코드를 볼 때 차이점을 찾으려고 에너지를 쏟게 되버린다. (극 공감)**

- 두 메소드가 똑같은 표현식을 쓴다면 하나로 줄일 수 있다.
- 어렴풋이 비슷한 것도 추출 해낼 수 있다.

## 3. Long Function (긴 함수)

짧은 함수의 효과

- 간접 호출의 효과
    1. 이해
    2. 공유
    3. 선택

**과거에는 짧은 함수 여럿은 호출 비용이 커서 지양되었으나,
요즘은 이런 걱정은 필요없다.**

+ 이름 조차도 짧게 지어놓는다면 이해 효과는 더 좋다.

매개 변수 or 임시 변수가 많다면???

1. 객체 형태로 통째로 넘겨서 매개변수의 수를 줄일 수 있다.
2. **임시 변수를 질의 함수로 바꾸기**를 통해 임시 변수의 수를 줄일 수 있다.

## 4. 긴 매개변수 목록 (Long Parameter List)

매개변수를 모조리 다 넣어버리면 이해 자체도 어렵고,
개인적인 생각 : 여러줄에 애매하게 걸쳐버리면 읽기도 싫어진다.

skill : 

1. 매개 변수를 질의 함수로 바꾸기.
2. **객체 통째로 넘기기**
3. 매개변수 객체 만들기
4. 플래그 인수 제거하기
5. 여러 함수를 클래스로 묶기

## 5. 전역 데이터 (Global Data)

1. 전역 변수
2. 클래스 변수
3. 싱글톤

등 에서  문제가 발생할 위험이 클 수 있다.

접근을 통제해야할 것 같다면 캡슐화 해서 제한하는 것이 가장 안전하다.

단, 불변의 데이터라면 약간 괜찮다.

## 6. 가변 데이터 (Mutable Data)

- 함수형 프로그래밍 기본 : 불변성 유지.
- 변수와 코드의 유효범위가 큰 경우에 치명적일 수 있음.

## 7. 뒤엉킨 변경 (Divergent Change)

SRP : (Single Responsibility Principle) 이 제대로 지켜지지 않을 떄 나타난다.

맥락에 따른 모듈 분리 필요.

순차적인 로직이라면 단계 분리 필요.

### 전략 패턴 & 방문자 패턴

변경 시 같이 변경할 대상을 함께 모아놓는 패턴.

## 8. 산탄총 수술 (Shotgun Surgery)

뒤엉킨 변경과 유사하나, 정 반대 개념.
발생과정에서 차이가 있다.

- 뒤엉킨 변경 : 한 코드에 섞여 들어가서 생김.
**⇒ 맥락 별로 분리 필요.**
- 산탄총 수술 : 여러 코드에 흩뿌려져 있어 생김.
**⇒ 맥락 별로 모음 필요.**

[Untitled](https://www.notion.so/a15d80a6ab81440ab52b159e26923a92)

## 9. 기능 편애 (Feature Envy)

자신이 속한 모듈보다 다른 모듈의 함수나 데이터와 상호작용이 많을 때.

- 다른 모듈의 데이터에 많이 접근한다면 데이터 근처로 옮겨준다.
- 일부 함수를 독립적으로 분리한다.
- 모듈을 옮겨준다.
- 등 ...

## 10. 데이터 뭉치 (Data Clumps)

데이터 뭉치를 추출해주어야 할 때.

- 데이터가 중복해서 사용될 때
- 데이터의 양이 클 때
- 데이터에 여러 필드가 있을 때

## 11. 기본형 집착 (Primitive Obsession)

기본형도 좋지만, 다양한 표현으로 사용자에게 일관적으로 보여줄 수 있어야 한다.

→ 객체로 바꾸기

→ 서브클래스 | 다형성

## 12. 반복되는 switch문 (Repeated Switches)

**switch문 —> 조건부 로직 다형성  으로 바꾸어야 한다.**

## 13. 반복문 (Loops)

**반복문 —> 파이프라인으로 바꾸기.**

filter, map과 같은 파이프라인 연산을 통해 각 원소들이 어떻게 처리되는지 쉽게 파악 가능.

### ToDo : 다형성 & 파이프라인 연산

## 14. 성의 없는 요소 (Lazy Element)

언어에서 제공하는 프로그래밍 요소의 틀에서 코딩을 하게 되면 

- 재활용
- 의미 있는 이름
- 쉬운 구조 변형

이 있지만, 

예제 그대로,  메서드가 많이 없는 클래스,  필요없는 기능이 많은 것들 
등은 없애 주는게 좋다.

⇒ 함수 인라인하기, 클래스 인라인하기, 계층 합치기 등을 적용.

## 15. 추측성 일반화 (Speculative Generality)

'나중에 필요할 거야'라는 생각으로 많이 만들어 두는 것.

→ 낭비.

## 16. 임시 필드 (Temporary Field)

특정 상황에서만 값이 설정되는 필드를 가진 클래스  ???

임시 필드는 코드 이해에 방해가 된다.

→ 유효한 클래스로 옮겨주거나,  유효하지 않을 때 사용할 전용 대안 클래스를 만들어준다.

## 17. 메시지 체인 (Message Chains)

방금 얻은 객체에서 또 다른 객체를 요청하는 식. : 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드.

→ 중간의 객체들이 모두 **중개자**가 돼버리기 쉽다.

- 위임 숨기기로 해결

    ```jsx
    managerName = aPerson.department.manager.name;
    // 이 있을 때, 
    // department,  manager,  name  등이 중계자가 될 수 있다. 쓰임을 미리 알고 체인의 존재를 숨기자.
    console.log( `${}께  ${}.. .${} .... );
    // 이 아니라,

    console.log( reportAutoGenerator.report(aPerson) );
    // aPerson만 전달해주는데, 보고서를 작성해주는 함수로 숨겨버렸다.
    ```

## 18. 중개자 (Middle Man)

객체의 대표적 기능 '캡슐화'에서 '위임'(delegation)이 자주 활용된다.

ex)  팀원이 팀장에게 미팅 요청을 할 때.

팀장이 요청 받은 것을  다이어리에 쓰든 / 일정 플랫폼에 쓰든 / 비서에게 알리든 
전달했던 팀원은 알 필요가 없다.

팀원 < = > 팀장  직접 소통한다면 효율적일 것.

## 19. 내부자 거래 (Insider Trading)

??????

여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식

## 20. 거대한 클래스 (Large Class)

한 클래스에서 많은 일을 한다면 필드가 늘어난다.

필드가 많아지면 → 중복 코드도 생길 것.

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 서브클래스로 바꾸기

등을 활용해서 거대한 클래스를 줄여주자.

## 21. 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

클래스의 장점 : 인터페이스가 같다는 가정하에 다른 클래스들로 교체할 수 있다.

인터페이스가 같아질 때 까지 클래스에 함수들을 옮겨놓고 대안 클래스를 만들어 놓는다.
단, 중복 코드가 생긴다면 슈퍼클래스 추출하기 를 적용할지 고려.

## 22. 데이터 클래스 (Data Class)

게터 / 세터 로만 이루어진 클래스

public은 다 숨겨주자.

변경하면 안된다면 setter를 숨겨주자.

근데, 불변인 데이터는 굳이 캡슐화가 필요없을 수도 있다.

## 23. 상속 포기 (Refused Bequest)

부모 클래스에서 메서드, 데이터를 상속 받을 때 : 

필요하지 않은 것들 : 

같은 계층에 서브클래스를 하나 새로 만든다.

메서드 내리기 / 필드 내리기를 활용해서 상속받지 않을 것들을 모조리 넘긴다.

---

근데 이 방식도 혼란과 문제를 야기 할 수 있다. 상속의 활용과 어긋난다.

⇒ 상속 메커니즘에서 벗어나보자.

## 24. 주석 (Comments)

주석이 나온 곳은 다시 한번 Refactoring을 해보자.

주석이 코드 블록 형태로 나온다면 함수 추출을 해보자.

주석으로 설명이 필요한 함수라면 함수 이름을 바꿔보자.